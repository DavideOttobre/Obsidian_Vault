# ğŸ“œ 1.8 Scope e Closure

## Introduzione

Lo **scope** definisce la visibilitÃ  e lâ€™accessibilitÃ  delle variabili nel codice.  
Le **closure** permettono a una funzione di **ricordare e accedere alle variabili** del proprio **scope esterno** anche dopo che la funzione Ã¨ stata eseguita.

In questa sezione vedremo:

- **Scope globale e locale**
- **Scope `var`, `let` e `const`**
- **Closure e loro utilizzo pratico**

---

## ğŸ”¹ 1. Scope (Ambito delle variabili)

### âœ… **Scope Globale**

Le variabili dichiarate **fuori da qualsiasi funzione** sono globali e accessibili ovunque.

```js
let globale = "Sono globale";

function mostraGlobale() {
    console.log(globale); // â "Sono globale"
}

mostraGlobale();
console.log(globale); // â "Sono globale"
```

ğŸ“Œ **Le variabili globali occupano memoria per tutta la durata del programma, quindi Ã¨ meglio usarle con cautela.**

---

### âœ… **Scope Locale (Funzioni e Blocchi)**

Le variabili dichiarate dentro una funzione esistono **solo allâ€™interno di quella funzione**.

```js
function locale() {
    let interno = "Sono dentro la funzione";
    console.log(interno); // Funziona
}

locale();
console.log(interno); // âŒ Errore! "interno" non Ã¨ definito fuori dalla funzione
```

ğŸ“Œ **Le variabili locali non inquinano lo scope globale.**

---

### âœ… **Differenza tra `var`, `let` e `const` nello scope**

```js
if (true) {
    var x = 10;  // Scope globale
    let y = 20;  // Scope di blocco
    const z = 30; // Scope di blocco
}

console.log(x); // âœ… Funziona (ma non Ã¨ sicuro)
console.log(y); // âŒ Errore! "y" Ã¨ nello scope di blocco
console.log(z); // âŒ Errore! "z" Ã¨ nello scope di blocco
```

ğŸ“Œ **Regole generali:**

- `var` **non ha scope di blocco** (evitarlo).
- `let` e `const` hanno **scope di blocco** (preferibili).
- `const` crea variabili **immutabili**.

---

## ğŸ”¹ 2. Closure

Una **closure** Ã¨ una funzione che mantiene lâ€™accesso alle variabili **del suo scope esterno**, anche dopo che la funzione esterna ha terminato l'esecuzione.

```js
function esterna() {
    let messaggio = "Ciao dal padre!";
    
    function interna() {
        console.log(messaggio); // Accede a "messaggio" della funzione esterna
    }

    return interna;
}

const miaFunzione = esterna();
miaFunzione(); // â "Ciao dal padre!"
```

ğŸ“Œ **Come funziona?**

1. `esterna()` viene eseguita, creando `messaggio` e `interna()`.
2. `esterna()` ritorna `interna`, ma **mantiene lâ€™accesso alla variabile `messaggio`**.
3. Quando chiamiamo `miaFunzione()`, `messaggio` Ã¨ ancora disponibile!

---

## ğŸ”¹ 3. Uso pratico delle Closure

### âœ… **Contatori indipendenti**

```js
function creaContatore() {
    let contatore = 0;
    
    return function() {
        contatore++;
        console.log("Contatore:", contatore);
    };
}

const contatore1 = creaContatore();
contatore1(); // â "Contatore: 1"
contatore1(); // â "Contatore: 2"

const contatore2 = creaContatore();
contatore2(); // â "Contatore: 1" (nuovo contatore indipendente)
```

ğŸ“Œ **Ogni volta che chiamiamo `creaContatore()`, viene creata una nuova closure con un contatore separato.**

---

### âœ… **Nascondere dati (Encapsulation)**

Possiamo usare le closure per **creare variabili private** che non sono accessibili dallâ€™esterno.

```js
function creaBanca() {
    let saldo = 1000;

    return {
        deposita: function(importo) {
            saldo += importo;
            console.log(`Saldo attuale: ${saldo}â‚¬`);
        },
        preleva: function(importo) {
            if (importo > saldo) {
                console.log("Fondi insufficienti!");
            } else {
                saldo -= importo;
                console.log(`Saldo attuale: ${saldo}â‚¬`);
            }
        }
    };
}

const mioConto = creaBanca();
mioConto.deposita(500); // â "Saldo attuale: 1500â‚¬"
mioConto.preleva(2000); // â "Fondi insufficienti!"
mioConto.preleva(1000); // â "Saldo attuale: 500â‚¬"
```

ğŸ“Œ **La variabile `saldo` Ã¨ protetta! Non puÃ² essere modificata direttamente dall'esterno.**

---

### âœ… **SetTimeout e Closure**

Quando usiamo `setTimeout`, la funzione "ricorda" lo scope in cui Ã¨ stata definita.

```js
function avviaTimer() {
    let messaggio = "Tempo scaduto!";
    
    setTimeout(function() {
        console.log(messaggio);
    }, 3000);
}

avviaTimer(); // â Dopo 3 secondi: "Tempo scaduto!"
```

ğŸ“Œ **La funzione dentro `setTimeout` mantiene l'accesso a `messaggio` anche dopo che `avviaTimer()` Ã¨ terminata.**

---

## ğŸ”¹ 4. Problemi comuni con le Closure

### âŒ **Uso errato di `var` nei loop**

```js
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
```

ğŸ“Œ **Output:**

```
3
3
3
```

âŒ **Errore:** Il valore di `i` Ã¨ 3 quando i `setTimeout` vengono eseguiti.

âœ… **Soluzione con `let` (scope di blocco):**

```js
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
```

ğŸ“Œ **Output corretto:**

```
0
1
2
```

âœ… Ora ogni iterazione ha la propria copia di `i`.

---

## ğŸ“Œ **Riepilogo**

|Concetto|Descrizione|
|---|---|
|**Scope Globale**|Variabili accessibili ovunque nel codice|
|**Scope Locale**|Variabili visibili solo dentro una funzione|
|**`var` vs `let` vs `const`**|`var` ha scope globale o di funzione, `let` e `const` hanno scope di blocco|
|**Closure**|Funzioni che ricordano le variabili del loro scope esterno|
|**Uso pratico delle Closure**|Contatori indipendenti, dati nascosti, gestione dello scope|

---

## Collegamenti utili

- **Prossimo argomento â†’ [[1.9 Errori e Debugging]]**
- **Ripassa le funzioni â†’ [[1.7 Funzioni]]**

---

# ðŸ“œ 3.5 Event Loop e Asincronia

## Introduzione

JavaScript Ã¨ **single-threaded**, il che significa che esegue **una riga di codice alla volta**.  
Tuttavia, grazie al **Event Loop**, puÃ² gestire operazioni **asincrone** come:  
âœ… **setTimeout e setInterval**  
âœ… **fetch API e richieste HTTP**  
âœ… **Eventi del browser**

In questa sezione vedremo:

- La Call Stack e lâ€™Event Loop
- La coda dei callback (Callback Queue e Microtask Queue)
- Come JavaScript gestisce il codice asincrono

---

## ðŸ”¹ 1. Call Stack (Pila di chiamate)

JavaScript usa una **Call Stack** per eseguire il codice in modo **sincrono**.

ðŸ“Œ **Funzionamento della Call Stack:**

1. Il codice viene eseguito **dallâ€™alto verso il basso**.
2. Ogni funzione chiamata viene **aggiunta alla stack**.
3. Quando una funzione termina, viene **rimossa dalla stack**.

âœ… **Esempio:**

```js
function uno() {
    console.log("Uno");
    due();
}

function due() {
    console.log("Due");
}

uno();
console.log("Tre");
```

ðŸ“Œ **Ordine di esecuzione:**

```
Uno
Due
Tre
```

âœ… **La Call Stack gestisce tutto in modo sincrono.**

---

## ðŸ”¹ 2. Il problema delle operazioni asincrone

Quando JavaScript incontra unâ€™operazione asincrona, come `setTimeout()`, **non puÃ² bloccare lâ€™esecuzione**.

### âŒ **Esempio di comportamento inatteso:**

```js
console.log("Inizio");

setTimeout(() => {
    console.log("Timeout completato!");
}, 2000);

console.log("Fine");
```

ðŸ“Œ **Output:**

```
Inizio
Fine
Timeout completato!
```

âœ… **PerchÃ©?**

- **`setTimeout()` viene registrato nel Web API Environment**.
- Il codice continua **senza aspettare**.
- Dopo 2 secondi, la funzione di `setTimeout` entra nella **Callback Queue**.
- Lâ€™Event Loop attende che la **Call Stack sia vuota** prima di eseguire la callback.

---

## ðŸ”¹ 3. Callback Queue e Microtask Queue

JavaScript usa **due code** per gestire operazioni asincrone:

1. **Callback Queue** â†’ Contiene i task di `setTimeout`, `setInterval`, eventi DOM.
2. **Microtask Queue** â†’ Contiene `Promises` (`.then()` e `.catch()`), `MutationObserver`.

ðŸ“Œ **Lâ€™Event Loop dÃ  prioritÃ  alla Microtask Queue!**

âœ… **Esempio di PrioritÃ :**

```js
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => console.log("C"));

console.log("D");
```

ðŸ“Œ **Ordine di esecuzione:**

```
A
D
C  <-- (Microtask Queue: Promessa risolta prima!)
B  <-- (Callback Queue: Timeout eseguito dopo)
```

âœ… **Microtask Queue (`then()`) ha prioritÃ  rispetto alla Callback Queue (`setTimeout()`).**

---

## ðŸ”¹ 4. Simulare il comportamento dellâ€™Event Loop

âœ… **Esempio di esecuzione con `setTimeout` e `Promise`:**

```js
console.log("Start");

setTimeout(() => console.log("setTimeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```

ðŸ“Œ **Ordine di esecuzione:**

```
Start
End
Promise   <-- (Microtask Queue ha la prioritÃ )
setTimeout <-- (Callback Queue viene eseguita dopo)
```

---

## ðŸ”¹ 5. Eseguire codice asincrono in ordine corretto

ðŸ“Œ **Soluzione con `async/await` per evitare problemi con le callback:**

```js
async function operazioni() {
    console.log("Inizio");

    await new Promise(resolve => setTimeout(resolve, 2000));

    console.log("Fine dopo 2 secondi");
}

operazioni();
console.log("Continuo...");
```

ðŸ“Œ **L'`await` blocca solo la funzione `async`, NON il codice globale!**

---

## ðŸ“Œ **Riepilogo**

|Concetto|Descrizione|
|---|---|
|**Call Stack**|Esegue il codice in modo sincrono|
|**Callback Queue**|Contiene `setTimeout`, `setInterval`, eventi DOM|
|**Microtask Queue**|Contiene `Promise.then()`, `MutationObserver`|
|**Event Loop**|Controlla se la Call Stack Ã¨ vuota e esegue le callback|
|**await**|Aspetta che una Promise sia risolta prima di continuare|

---

## Collegamenti utili

- **Prossimo argomento â†’ [[4.1 Il DOM]]**
- **Ripassa la Programmazione Funzionale â†’ [[3.4 Programmazione Funzionale]]**

---
